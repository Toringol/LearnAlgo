/*
* 4.1.5
* Воспользуйтесь приведенными далее идеями для разработки нерекурсивного
* алгоритма поиска максимального подмассива за линейное время. Начните с
* левого конца массива и двигайтесь вправо, отслеживая найденный к данному
* моменту максимальный подмассив. Зная максимальный подмассив массива A[i..j],
* распространите ответ на поиск максимального подмассива, заканчивающегося
* индексом j + 1, воспользовавшись следующим наблюдением: максимальный подмассив
* массива A[1..j + 1] представляет собой либо максимальный подмассив массива
* A[1..j], либо подмассив A[i..j + 1] для некоторого 1 <= i <= j + 1.
* Определите максимальный подмассив вида A[i..j + 1] за константное время, зная
* максимальный подмассив, заканчивающийся индексом j.
 */

package main

import (
	"fmt"
	"math"
)

func findMaxSubArray(nums []int) int {
	partSum, maxSum := 0, math.MinInt64

	for _, num := range nums {
		partSum += num
		maxSum = max(maxSum, partSum)
		if partSum < 0 {
			partSum = 0
		}
	}

	return maxSum
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	nums := []int{13, -3, -25, 20, -3, -16, -23,
		18, 20, -7, 12, -5, -22, 15, -4, 7}

	fmt.Println(findMaxSubArray(nums))
}
